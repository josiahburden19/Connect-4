function init(self)
	self.size = vmath.vector3()
	self.size.x, self.size.y = window.get_size()
	self.tile_size = 100
	self.rows, self.columns = 6, 7
	self.list_coords_x = {}
	self.factory_instances = {}
	self.first_coord = vmath.vector3()
	self.snap_coord = vmath.vector3(0, 680, 1)
	self.board = {}
	self.turn = false
	self.started_snapping = false
	self.connect_fours = {}
	
	local coord = vmath.vector3()
	for i=0, self.columns-1, 1 do
		self.factory_instances[i + 1] = {}
		for j=0, self.rows-1, 1 do
			coord.x = (i*self.tile_size) + (self.size.x/2) - (self.columns * self.tile_size/2) + (self.tile_size/2)
			coord.y = (j*self.tile_size) + (self.size.y/2) - (self.rows * self.tile_size/2) + (self.tile_size/2) - 50
			self.factory_instances[i + 1][j + 1] = factory.create('#factory', vmath.vector3(coord.x, coord.y, 0))
			if i == 0 and j == 0 then
				self.first_coord = coord
			end
		end
		table.insert(self.list_coords_x, coord.x)
	end

	for i = 0, self.columns + 1, 1 do
		self.board[i] = {}
	end
	msg.post('.', 'acquire_input_focus')
end

function on_input(self, action_id, action)
	if action_id == nil then
		self.snap_coord.x = (math.ceil((action.x-83 + (self.columns%2)*(self.tile_size/2))/self.tile_size) * self.tile_size) + 33 - (self.columns%2)*(self.tile_size/2)
		if self.started_snapping == false then
			go.set_position(self.snap_coord, '/token')
			self.started_snapping = true
		else
			go.animate('/token', 'position', go.PLAYBACK_ONCE_FORWARD, self.snap_coord, go.EASING_OUTEXPO, 0.4)
		end
	end
	if action_id == hash('touch') and action.pressed and indexOf(self.list_coords_x, self.snap_coord.x) ~= nil then
		place(self, self.turn)
		checkBoard(self)
		self.turn = not self.turn
		if self.turn then
			sprite.play_flipbook('/token', 'token_2')
		else
			sprite.play_flipbook('/token', 'token_1')
		end
	end
end

function indexOf(array, value)
	for i, v in ipairs(array) do
		if v == value then
			return i
		end
	end
	return nil
end

function tableLength(t)
	local count = 0
	for _ in pairs(t) do count = count + 1 end
	return count
end

function place(self, token)
	local coord = vmath.vector3()
	local index = indexOf(self.list_coords_x, self.snap_coord.x)
	if tableLength(self.board[index]) < self.rows then
		table.insert(self.board[index], token)
		coord.y = self.first_coord.y - (self.rows - tableLength(self.board[index])) * self.tile_size
		coord.x = self.snap_coord.x
		if not token then
			local spawned = factory.create('/token_1_factory#factory', vmath.vector3(coord.x, 680, 1))
			go.animate(spawned, 'position.y', go.PLAYBACK_ONCE_FORWARD, coord.y, go.EASING_OUTBOUNCE, 1)
		elseif token then
			local spawned = factory.create('/token_2_factory#factory', vmath.vector3(coord.x, 680, 1))
			go.animate(spawned, 'position.y', go.PLAYBACK_ONCE_FORWARD, coord.y, go.EASING_OUTBOUNCE, 1)
		end
	end
end

function checkBoard(self)
	function checkAround(self, coord, token)
		function checkDirection(self, coord, token, direction, times)
			for i=1, times - 2, 1 do
				if not (self.board[coord.x + i * (direction.x)][coord.y + i * (direction.y)] == token) then
					return {false}
				end
			end
			return {true, direction}
		end

		local is_true = {}
		for i=-1, 1, 1 do
			for j=-1, 1, 1 do
				if self.board[coord.x + i][coord.y + j] == token and not (j == 0 and i == 0) then
					local new_coord = vmath.vector3(coord.x + i, coord.y + j, 0)
					local checked_direction = checkDirection(self, new_coord, token, vmath.vector3(i, j, 0), 4)
					if checked_direction[1] then
						table.insert(is_true, checked_direction[2])
					end
				end
			end
		end
		return is_true
	end
	
	for i=1, self.columns, 1 do
		for j=1, self.rows, 1 do
			if self.board[i][j] ~= nil then
				local checked_board = checkAround(self, vmath.vector3(i, j, 0), self.board[i][j])
				for k in pairs(checked_board) do
					print(i, j, checked_board[k])
					for l=0, 3, 1 do
						local instance = tostring(self.factory_instances[i + l * (checked_board[k].x)][j + l * (checked_board[k].y)])
						instance = string.sub(instance, 8, -2) .. '#sprite'
						go.animate(instance, 'tint', go.PLAYBACK_ONCE_FORWARD, vmath.vector4(0.5, 1, 0.4, 1), go.EASING_LINEAR, 1)
					end
				end
			end
		end
	end
end
	